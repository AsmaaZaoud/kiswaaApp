package expo.modules.imagepicker

import android.Manifest
import android.content.Context
import android.content.Intent
import android.graphics.Bitmap
import android.media.MediaMetadataRetriever
import android.net.Uri
import expo.modules.core.errors.ModuleNotFoundException
import android.os.OperationCanceledException
import expo.modules.imagepicker.contracts.CameraContract
import expo.modules.imagepicker.contracts.CameraContractOptions
import expo.modules.imagepicker.contracts.CropImageContract
import expo.modules.imagepicker.contracts.CropImageContractOptions
import expo.modules.imagepicker.contracts.ImageLibraryContract
import expo.modules.imagepicker.contracts.ImageLibraryContractOptions
import expo.modules.imagepicker.contracts.ImagePickerContractResult
import expo.modules.interfaces.permissions.Permissions
import expo.modules.interfaces.permissions.PermissionsResponse
import expo.modules.interfaces.permissions.PermissionsResponseListener
import expo.modules.interfaces.permissions.PermissionsStatus
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.coroutines.withContext
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

class ImagePickerModule(
  private val mContext: Context,
  private val moduleRegistryDelegate: ModuleRegistryDelegate = ModuleRegistryDelegate(),
  private val pickerResultStore: PickerResultsStore = PickerResultsStore(mContext)
) : ExportedModule(mContext), ActivityEventListener, LifecycleEventListener {

  private var mCameraCaptureURI: Uri? = null
  private var mPromise: Promise? = null
  private var mPickerOptions: ImagePickerOptions? = null
  private val moduleCoroutineScope = CoroutineScope(Dispatchers.IO)
  private var exifDataHandler: ExifDataHandler? = null

  override fun definition() = ModuleDefinition {

    Name(moduleName)

    // region JS API

    AsyncFunction("requestMediaLibraryPermissionsAsync") { writeOnly: Boolean, promise: Promise ->
      Permissions.askForPermissionsWithPermissionsManager(appContext.permissions, promise, *getMediaLibraryPermissions(writeOnly))
    }

    AsyncFunction("getMediaLibraryPermissionsAsync") { writeOnly: Boolean, promise: Promise ->
      Permissions.getPermissionsWithPermissionsManager(appContext.permissions, promise, *getMediaLibraryPermissions(writeOnly))
    }

    AsyncFunction("requestCameraPermissionsAsync") { promise: Promise ->
      Permissions.askForPermissionsWithPermissionsManager(appContext.permissions, promise, Manifest.permission.CAMERA)
    }

    AsyncFunction("getCameraPermissionsAsync") { promise: Promise ->
      Permissions.getPermissionsWithPermissionsManager(appContext.permissions, promise, Manifest.permission.CAMERA)
    }

    AsyncFunction("launchCameraAsync") Coroutine { options: ImagePickerOptions ->
      ensureTargetActivityIsAvailable(options)
      ensureCameraPermissionsAreGranted()

      val mediaFile = createOutputFile(context.cacheDir, options.mediaTypes.toFileExtension())
      val uri = mediaFile.toContentUri(context)
      val contractOptions = options.toCameraContractOptions(uri)

      launchContract({ cameraLauncher.launch(contractOptions) }, options)
    }

    AsyncFunction("launchImageLibraryAsync") Coroutine { options: ImagePickerOptions ->
      val contractOptions = options.toImageLibraryContractOptions()
      launchContract({ imageLibraryLauncher.launch(contractOptions) }, options)
    }

    AsyncFunction("getPendingResultAsync") Coroutine { ->
      val (bareResult, options) = pendingMediaPickingResult ?: return@Coroutine null

      pendingMediaPickingResult = null

      mediaHandler.readExtras(bareResult, options)
    }

    // endregion

    OnCreate {
      coroutineScope.launch {
        withContext(Dispatchers.Main) {
          cameraLauncher = appContext.registerForActivityResult(
            CameraContract(this@ImagePickerModule),
          ) { input, result -> handleResultUponActivityDestruction(result, input.options) }
          imageLibraryLauncher = appContext.registerForActivityResult(
            ImageLibraryContract(this@ImagePickerModule),
          ) { input, result -> handleResultUponActivityDestruction(result, input.options) }
          cropImageLauncher = appContext.registerForActivityResult(
            CropImageContract(this@ImagePickerModule),
          ) { input, result -> handleResultUponActivityDestruction(result, input.options) }
        }
      }
    }
  }

  // TODO (@bbarthec): generalize it as almost every module re-declares this approach
  val context: Context
    get() = requireNotNull(appContext.reactContext) { "React Application Context is null" }

  private val currentActivity
    get() = appContext.activityProvider?.currentActivity ?: throw MissingCurrentActivityException()

  private val mediaHandler = MediaHandler(this)

  private lateinit var cameraLauncher: AppContextActivityResultLauncher<CameraContractOptions, ImagePickerContractResult>
  private lateinit var imageLibraryLauncher: AppContextActivityResultLauncher<ImageLibraryContractOptions, ImagePickerContractResult>
  private lateinit var cropImageLauncher: AppContextActivityResultLauncher<CropImageContractOptions, ImagePickerContractResult>

  /**
   * Android system sometimes kills the `MainActivity` after the `ImagePicker` finishes.
   * Moreover, the react context will be reloaded again in such a case. We need to handle this situation.
   * To do it we track if the current activity was destroyed.
   */
  private var mWasHostDestroyed = false

  private val mImageLoader: ImageLoaderInterface by moduleRegistry()
  private val mUIManager: UIManager by moduleRegistry()
  private val mPermissions: Permissions by moduleRegistry()
  private val mActivityProvider: ActivityProvider by moduleRegistry()

  private lateinit var _experienceActivity: WeakReference<Activity>

  private val experienceActivity: Activity?
    get() {
      if (!this::_experienceActivity.isInitialized) {
        _experienceActivity = WeakReference(mActivityProvider.currentActivity)
      }

      return _experienceActivity.get()
    }

  private inline fun <reified T> moduleRegistry() = moduleRegistryDelegate.getFromModuleRegistry<T>()

  override fun onCreate(moduleRegistry: ModuleRegistry) {
    moduleRegistryDelegate.onCreate(moduleRegistry)
    mUIManager.registerLifecycleEventListener(this)
  }

  override fun getName() = "ExponentImagePicker"

  //region expo methods

  @ExpoMethod
  fun requestMediaLibraryPermissionsAsync(writeOnly: Boolean, promise: Promise) {
    Permissions.askForPermissionsWithPermissionsManager(mPermissions, promise, *getMediaLibraryPermissions(writeOnly))
  }

  @ExpoMethod
  fun getMediaLibraryPermissionsAsync(writeOnly: Boolean, promise: Promise) {
    Permissions.getPermissionsWithPermissionsManager(mPermissions, promise, *getMediaLibraryPermissions(writeOnly))
  }

  @ExpoMethod
  fun requestCameraPermissionsAsync(promise: Promise) {
    Permissions.askForPermissionsWithPermissionsManager(mPermissions, promise, Manifest.permission.CAMERA)
  }

  @ExpoMethod
  fun getCameraPermissionsAsync(promise: Promise) {
    Permissions.getPermissionsWithPermissionsManager(mPermissions, promise, Manifest.permission.CAMERA)
  }

  @ExpoMethod
  fun getPendingResultAsync(promise: Promise) {
    promise.resolve(pickerResultStore.getAllPendingResults())
  }

  // NOTE: Currently not reentrant / doesn't support concurrent requests
  @ExpoMethod
  fun launchCameraAsync(options: Map<String, Any?>, promise: Promise) {
    val pickerOptions = optionsFromMap(options, promise) ?: return

    val activity = experienceActivity.ifNull {
      promise.reject(ImagePickerConstants.ERR_MISSING_ACTIVITY, ImagePickerConstants.MISSING_ACTIVITY_MESSAGE)
      return
    }

    val intentType = if (pickerOptions.mediaTypes == MediaTypes.VIDEOS) MediaStore.ACTION_VIDEO_CAPTURE else MediaStore.ACTION_IMAGE_CAPTURE
    val cameraIntent = Intent(intentType)
    cameraIntent.resolveActivity(activity.application.packageManager).ifNull {
      promise.reject(IllegalStateException("Error resolving activity"))
      return
    }

    val permissionsResponseHandler = PermissionsResponseListener { permissionsResponse: Map<String, PermissionsResponse> ->
      if (permissionsResponse[Manifest.permission.WRITE_EXTERNAL_STORAGE]?.status == PermissionsStatus.GRANTED &&
        permissionsResponse[Manifest.permission.CAMERA]?.status == PermissionsStatus.GRANTED
      ) {
        launchCameraWithPermissionsGranted(promise, cameraIntent, pickerOptions)
      } else {
        promise.reject(SecurityException("User rejected permissions"))
      }
    }

    mPermissions.askForPermissions(permissionsResponseHandler, Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.CAMERA)
  }

  // NOTE: Currently not reentrant / doesn't support concurrent requests
  @ExpoMethod
  fun launchImageLibraryAsync(options: Map<String, Any?>, promise: Promise) {
    val pickerOptions = optionsFromMap(options, promise) ?: return

    val libraryIntent = Intent().apply {
      when (pickerOptions.mediaTypes) {
        MediaTypes.IMAGES -> type = "image/*"
        MediaTypes.VIDEOS -> type = "video/*"
        MediaTypes.ALL -> {
          type = "*/*"
          putExtra(Intent.EXTRA_MIME_TYPES, arrayOf("image/*", "video/*"))
        }
      }
      mediaHandler.readExtras(result.data, options)
    } catch (cause: OperationCanceledException) {
      ImagePickerCancelledResponse()
    }

    startActivityOnResult(libraryIntent, ImagePickerConstants.REQUEST_LAUNCH_IMAGE_LIBRARY, promise, pickerOptions)
  }

  //endregion

  //region helpers

  // endregion

  // region Utils

  private fun getMediaLibraryPermissions(writeOnly: Boolean): Array<String> =
    if (writeOnly) {
      arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE)
    } else {
      arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE)
    }

  private fun ensureTargetActivityIsAvailable(options: ImagePickerOptions) {
    val cameraIntent = Intent(options.mediaTypes.toCameraIntentAction())
    if (cameraIntent.resolveActivity(currentActivity.application.packageManager) == null) {
      throw MissingActivityToHandleIntent(cameraIntent.type)
    }
  }

  private fun launchCameraWithPermissionsGranted(promise: Promise, cameraIntent: Intent, pickerOptions: ImagePickerOptions) {
    val imageFile = createOutputFile(
      mContext.cacheDir,
      if (pickerOptions.mediaTypes == MediaTypes.VIDEOS) ".mp4" else ".jpg"
    ).ifNull {
      promise.reject(IOException("Could not create image file."))
      return
    }

    permissions.askForPermissions(
      { permissionsResponse ->
        if (
          permissionsResponse[Manifest.permission.WRITE_EXTERNAL_STORAGE]?.status == PermissionsStatus.GRANTED &&
          permissionsResponse[Manifest.permission.CAMERA]?.status == PermissionsStatus.GRANTED
        ) {
          continuation.resume(Unit)
        } else {
          PendingPromise(pickerResultStore)
        }
      },
      Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.CAMERA
    )
  }

  //endregion

  //region activity for result

  private fun startActivityOnResult(intent: Intent, requestCode: Int, promise: Promise, pickerOptions: ImagePickerOptions) {
    experienceActivity
      .ifNull {
        promise.reject(ImagePickerConstants.ERR_MISSING_ACTIVITY, ImagePickerConstants.MISSING_ACTIVITY_MESSAGE)
        return
      }
      .also {
        mUIManager.registerActivityEventListener(this)
        mPromise = promise
        mPickerOptions = pickerOptions
      }
      .startActivityForResult(intent, requestCode)
  }

  private fun shouldHandleOnActivityResult(activity: Activity, requestCode: Int): Boolean {
    return experienceActivity != null &&
      mPromise != null &&
      mPickerOptions != null &&
      // When we launched the crop tool and the android kills current activity, the references can be different.
      // So, we fallback to the requestCode in this case.
      (activity === experienceActivity || mWasHostDestroyed && requestCode == CropImage.CROP_IMAGE_ACTIVITY_REQUEST_CODE)
  }

  private fun handleOnActivityResult(promise: Promise, activity: Activity, requestCode: Int, resultCode: Int, intent: Intent?, pickerOptions: ImagePickerOptions) {
    if (resultCode != Activity.RESULT_OK) {
      promise.resolve(
        Bundle().apply {
          putBoolean("cancelled", true)
        }
      )
      return
    }

    val contentResolver = activity.application.contentResolver

    if (requestCode == CropImage.CROP_IMAGE_ACTIVITY_REQUEST_CODE) {
      val result = CropImage.getActivityResult(intent).ifNull {
        promise.reject(ImagePickerConstants.ERR_CROPPING_FAILURE, ImagePickerConstants.CROPPING_FAILURE_MESSAGE)
        return
      }

      val exporter = CropImageExporter(result.rotation, result.cropRect, pickerOptions.isBase64)
      ImageResultTask(
        promise,
        result.uri,
        contentResolver,
        CropFileProvider(result.uri),
        pickerOptions.isAllowsEditing,
        pickerOptions.isExif,
        exporter,
        exifDataHandler,
        moduleCoroutineScope
      ).execute()
      return
    }

    val uri = (if (requestCode == ImagePickerConstants.REQUEST_LAUNCH_CAMERA) mCameraCaptureURI else intent?.data)
      .ifNull {
        promise.reject(ImagePickerConstants.ERR_MISSING_URL, ImagePickerConstants.MISSING_URL_MESSAGE)
        return
      }

    val type = getType(contentResolver, uri).ifNull {
      promise.reject(ImagePickerConstants.ERR_CAN_NOT_DEDUCE_TYPE, ImagePickerConstants.CAN_NOT_DEDUCE_TYPE_MESSAGE)
      return
    }

    if (type.contains("image")) {
      if (pickerOptions.isAllowsEditing) {
        // if the image is created by camera intent we don't need a new file - it's been already saved
        val needGenerateFile = requestCode != ImagePickerConstants.REQUEST_LAUNCH_CAMERA
        startCropIntent(promise, uri, type, needGenerateFile, pickerOptions)
        return
      }

      val exporter: ImageExporter = if (pickerOptions.quality == ImagePickerConstants.DEFAULT_QUALITY) {
        RawImageExporter(contentResolver, pickerOptions.isBase64)
      } else {
        CompressionImageExporter(mImageLoader, pickerOptions.quality, pickerOptions.isBase64)
      }

      ImageResultTask(
        promise,
        uri,
        contentResolver,
        CacheFileProvider(mContext.cacheDir, deduceExtension(type)),
        pickerOptions.isAllowsEditing,
        pickerOptions.isExif,
        exporter,
        exifDataHandler,
        moduleCoroutineScope
      ).execute()
      return
    }

    try {
      val metadataRetriever = MediaMetadataRetriever().apply {
        setDataSource(mContext, uri)
      }
      VideoResultTask(promise, uri, contentResolver, CacheFileProvider(mContext.cacheDir, ".mp4"), metadataRetriever, moduleCoroutineScope).execute()
    } catch (e: RuntimeException) {
      e.printStackTrace()
      promise.reject(ImagePickerConstants.ERR_CAN_NOT_EXTRACT_METADATA, ImagePickerConstants.CAN_NOT_EXTRACT_METADATA_MESSAGE, e)
      return
    }
  }

  //endregion

  //region LifecycleEventListener

  override fun onHostDestroy() {
    mWasHostDestroyed = true
  }

  override fun onHostResume() {
    if (mWasHostDestroyed) {
      _experienceActivity = WeakReference(mActivityProvider.currentActivity)
      mWasHostDestroyed = false
    }
  }
  override fun onHostPause() = Unit

  //endregion
}
